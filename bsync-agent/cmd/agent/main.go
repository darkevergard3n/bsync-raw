package main

import (
	"context"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"time"

	"bsync-agent/internal/agent"
	"bsync-agent/internal/embedded"
	"gopkg.in/yaml.v2"
)

const (
	Version = "1.0.0-dev"
)

var (
	configFile = flag.String("config", "", "Configuration file path")
	dataDir    = flag.String("data", "", "Data directory (overrides config)")
	serverURL  = flag.String("server", "", "Server URL (overrides config)")
	agentID    = flag.String("agent-id", "", "Agent ID (overrides config)")
	logLevel   = flag.String("log-level", "info", "Log level (debug, info, warn, error)")
	version    = flag.Bool("version", false, "Show version information")
	daemon     = flag.Bool("daemon", false, "Run as daemon")
)

func main() {
	flag.Parse()

	// Show version and exit
	if *version {
		fmt.Printf("BSync Integrated v%s\n", Version)
		fmt.Printf("Built with Go %s\n", runtime.Version())
		fmt.Printf("Embedded BSync Core\n")
		os.Exit(0)
	}

	// Check for CLI commands
	if len(flag.Args()) > 0 {
		handleCLICommand(flag.Args())
		return
	}

	// Load configuration
	config, err := loadConfig()
	if err != nil {
		log.Fatalf("Failed to load configuration: %v", err)
	}

	// Setup logging
	setupLogging(*logLevel)

	log.Printf("BSync Integrated v%s starting...", Version)
	log.Printf("Agent ID: %s", config.AgentID)
	log.Printf("Data Directory: %s", config.Syncthing.DataDir)
	log.Printf("Server URL: %s", config.ServerURL)

	// Create integrated agent
	integratedAgent, err := agent.NewIntegratedAgent(config)
	if err != nil {
		log.Fatalf("Failed to create integrated agent: %v", err)
	}

	// Setup context for graceful shutdown
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Setup OS-specific signal handling
	sigChan := setupSignalHandling()

	// Start the agent
	if err := integratedAgent.Start(ctx); err != nil {
		log.Fatalf("Failed to start integrated agent: %v", err)
	}

	// Run as daemon or foreground
	if *daemon {
		log.Println("Running as daemon...")
		runAsDaemon(ctx, integratedAgent, sigChan)
	} else {
		log.Println("Running in foreground (press Ctrl+C to stop)...")
		runForeground(ctx, integratedAgent, sigChan)
	}

	log.Println("BSync shutting down...")
}

func loadConfig() (*agent.AgentConfig, error) {
	config := &agent.AgentConfig{
		// Default values - AgentID will be auto-generated if not specified
		AgentID:   "",  // Empty string allows dynamic generation
		ServerURL: "wss://localhost:8090",
		Syncthing: embedded.SyncthingConfig{
			DataDir:       "./data",
			ListenAddress: "tcp://0.0.0.0:22101",
			Folders:       []embedded.FolderConfig{},
			Devices:       []embedded.DeviceConfig{},
			Options:       make(map[string]interface{}),
		},
		Monitoring: agent.MonitoringConfig{
			Enabled:        true,
			ReportInterval: 60 * time.Second,
		},
		LogLevel: "info",
	}

	// Load from config file if specified
	if *configFile != "" {
		if err := loadConfigFromFile(*configFile, config); err != nil {
			return nil, fmt.Errorf("failed to load config file %s: %w", *configFile, err)
		}
	}

	// Override with command line flags
	if *dataDir != "" {
		config.Syncthing.DataDir = *dataDir
	}
	if *serverURL != "" {
		config.ServerURL = *serverURL
	}
	if *agentID != "" {
		config.AgentID = *agentID
	}
	if *logLevel != "" {
		config.LogLevel = *logLevel
	}

	// Agent ID will be generated by NewIntegratedAgent if needed

	// Transfer EventDebug from AgentConfig to SyncthingConfig
	config.Syncthing.EventDebug = config.EventDebug

	// Ensure data directory is absolute
	if !filepath.IsAbs(config.Syncthing.DataDir) {
		abs, err := filepath.Abs(config.Syncthing.DataDir)
		if err != nil {
			return nil, fmt.Errorf("failed to get absolute path for data directory: %w", err)
		}
		config.Syncthing.DataDir = abs
	}

	// Create data directory if it doesn't exist
	if err := os.MkdirAll(config.Syncthing.DataDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create data directory: %w", err)
	}

	return config, nil
}

func loadConfigFromFile(filename string, config *agent.AgentConfig) error {
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		return err
	}

	err = yaml.Unmarshal(data, config)
	if err != nil {
		return err
	}

	// Expand environment variables in data_dir path
	config.Syncthing.DataDir = expandEnvPath(config.Syncthing.DataDir)

	// Debug: Show what was loaded from config file
	log.Printf("Loaded from config file: ListenAddress = %s", config.Syncthing.ListenAddress)
	log.Printf("Loaded data_dir (after env expansion): %s", config.Syncthing.DataDir)
	return nil
}

func setupLogging(level string) {
	// For now, just use standard log package
	// TODO: Implement proper structured logging with logrus or zap
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	
	switch level {
	case "debug":
		log.SetOutput(os.Stdout)
	case "info":
		log.SetOutput(os.Stdout)
	case "warn":
		log.SetOutput(os.Stdout)
	case "error":
		log.SetOutput(os.Stderr)
	}
}

func runForeground(ctx context.Context, agent *agent.IntegratedAgent, sigChan chan os.Signal) {
	for {
		// Wait for signal
		sig := <-sigChan
		log.Printf("Received signal: %v", sig)
		
		// Handle signal using OS-specific logic
		if shouldExit := handleSignal(sig, agent); shouldExit {
			return
		}
	}
}

func runAsDaemon(ctx context.Context, agent *agent.IntegratedAgent, sigChan chan os.Signal) {
	// TODO: Implement proper daemonization
	// For now, just run like foreground but without interactive messages
	runForeground(ctx, agent, sigChan)
}

func handleCLICommand(args []string) {
	command := args[0]
	
	switch command {
	case "status":
		handleStatusCommand(args[1:])
	case "folders":
		handleFoldersCommand(args[1:])
	case "devices":
		handleDevicesCommand(args[1:])
	case "scan":
		handleScanCommand(args[1:])
	case "version":
		fmt.Printf("BSync Integrated v%s\n", Version)
	case "help", "--help", "-h":
		showUsage()
	default:
		fmt.Printf("Unknown command: %s\n", command)
		showUsage()
		os.Exit(1)
	}
}

func handleStatusCommand(args []string) {
	fmt.Println("Status command not yet implemented")
	fmt.Println("This will show the current status of the integrated agent")
	// TODO: Connect to running agent via local API and get status
}

func handleFoldersCommand(args []string) {
	fmt.Println("Folders command not yet implemented")
	fmt.Println("This will show folder information")
	// TODO: Connect to running agent via local API and get folder status
}

func handleDevicesCommand(args []string) {
	fmt.Println("Devices command not yet implemented")
	fmt.Println("This will show device connection information")
	// TODO: Connect to running agent via local API and get device connections
}

func handleScanCommand(args []string) {
	if len(args) == 0 {
		fmt.Println("Usage: BSync scan <folder-id>")
		os.Exit(1)
	}
	
	folderID := args[0]
	fmt.Printf("Scan command for folder '%s' not yet implemented\n", folderID)
	// TODO: Connect to running agent via local API and trigger scan
}

func showUsage() {
	fmt.Printf("BSync Integrated v%s\n\n", Version)
	fmt.Println("USAGE:")
	fmt.Println("  BSync [OPTIONS]")
	fmt.Println("  BSync [OPTIONS] COMMAND [ARGS...]")
	fmt.Println("")
	fmt.Println("OPTIONS:")
	fmt.Println("  --config FILE        Configuration file path")
	fmt.Println("  --data DIR           Data directory (overrides config)")
	fmt.Println("  --server URL         Server URL (overrides config)")
	fmt.Println("  --agent-id ID        Agent ID (overrides config)")
	fmt.Println("  --log-level LEVEL    Log level: debug, info, warn, error")
	fmt.Println("  --daemon             Run as daemon")
	fmt.Println("  --version            Show version information")
	fmt.Println("  --help               Show this help")
	fmt.Println("")
	fmt.Println("COMMANDS:")
	fmt.Println("  status               Show agent and sync status")
	fmt.Println("  folders              List and manage folders")
	fmt.Println("  devices              Show device connections")
	fmt.Println("  scan FOLDER-ID       Trigger folder scan")
	fmt.Println("  version              Show version information")
	fmt.Println("  help                 Show this help")
	fmt.Println("")
	fmt.Println("EXAMPLES:")
	fmt.Println("  BSync --config /etc/bsync/agent.yaml")
	fmt.Println("  BSync --data /var/lib/bsync --server ws://sync.company.com")
	fmt.Println("  BSync status")
	fmt.Println("  BSync folders")
	fmt.Println("  BSync scan documents")
}

// expandEnvPath expands environment variables in path
// Supports both Unix-style ${VAR} and Windows-style %VAR% formats
func expandEnvPath(path string) string {
	if path == "" {
		return path
	}

	// First expand Unix-style environment variables ${VAR} and $VAR
	expanded := os.ExpandEnv(path)

	// Then expand Windows-style environment variables %VAR%
	// Only do this if the path contains % characters
	if strings.Contains(expanded, "%") {
		expanded = expandWindowsEnvVars(expanded)
	}

	return expanded
}

// expandWindowsEnvVars expands Windows-style %VAR% environment variables
func expandWindowsEnvVars(path string) string {
	// Regex to match %VARNAME% pattern
	re := regexp.MustCompile(`%([A-Za-z_][A-Za-z0-9_]*)%`)

	return re.ReplaceAllStringFunc(path, func(match string) string {
		// Extract variable name (remove % symbols)
		varName := match[1 : len(match)-1]

		// Get environment variable value
		if value := os.Getenv(varName); value != "" {
			return value
		}

		// If environment variable is not found, return original match
		return match
	})
}

func generateID() string {
	// Simple ID generation for now
	return fmt.Sprintf("%d", time.Now().Unix())
}


